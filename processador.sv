/*# -*- coding: utf-8 -*-
processador.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kgKtCoc5bvOoz8lckrXmHIc2PwVYL_XD

## Projeto de processador (versão final)

Author: Wedryson Lucas

# Commented out IPython magic to ensure Python compatibility.
# # biblioteca do verilog
# %%bash
# sudo apt-get update
# sudo apt-get install verilog iverilog gtkwave

# Commented out IPython magic to ensure Python compatibility.
!pip install git+https://github.com/lesc-ufv/cad4u >& /dev/null
!git clone https://github.com/lesc-ufv/cad4u >& /dev/null
# %load_ext plugin
*/

# %%file pc.sv
# // Contador de programa (PC)
# module pc (clk, comandos, instruction, zero, address);
#   // Declaracao de portas
#   input clk, zero;
#   input [9:0] comandos;
#   input [15:0] instruction;
#   output reg [15:0] address;
# 
#   // Variaveis intermediarias
#   wire [15:0] extensao = { 8'd0, instruction[7:0] };
#   wire [15:0] shift = extensao << 2;
#   wire muxBranch = comandos[3]; // Branch
#   wire muxJump = comandos[0]; // Jump
# 
#   // Iniciando endereco
#   initial begin
#     address = -16'd2;
#   end
# 
#   // Funcionamento do contador
#   always @( posedge clk ) begin
#     address <= address + 16'd2;
#     // Condicao do Jump
#     if ( muxJump == 1'b1 ) begin
#       // Implementar ! ! !
#     end
#     // Condicao do Branch
#     if (( muxBranch == 1'b1 ) & ( zero == 1'b1 ) & ( muxJump == 1'b0 )) begin
#       address <= address + shift;
#     end
#   end
# 
# endmodule

/**Instruções:**

**lw rs, Offset(rt);**

* 3 bits ( opcode ) = **011**
* 3 bits ( registrador fonte ) = **000**
* 3 bits ( registrador destino ) = **010**
* 7 bits ( imediato ) = **0000101**

```

Ex.: lw $s1, 3($s0);
         $s1 = ($s0) + 32'd3;
         $s1 = 3;
```

**lw rs, Offset(rt);**

* 3 bits ( opcode ) = **011**
* 3 bits ( registrador fonte ) = **000**
* 3 bits ( registrador destino ) = **100**
* 7 bits ( imediato ) = **0000010**

```
Ex.: lw $s2, 5($s0);
         $s2 = ($s0) + 32'd5;
         $s2 = 5;
```

**add rs, rt, rd;**

* 3 bits ( opcode ) = **000**
* 3 bits ( registrador origem 1 ) = **010**
* 3 bits ( registrador origem 2 ) = **100**
* 3 bits ( registrador destino ) = **101**
* 4 bits ( funct - variacoes das operacoes especificadas do opcode ) = **0000**

```
Ex.: add $s3, $s1, $s2;
         $s3 = 3 + 5 = 8
```

---

**sub rs, rt, rd;**

* 3 bits ( opcode ) = **000**
* 3 bits ( registrador origem 1 ) = **010**
* 3 bits ( registrador origem 2 ) = **100**
* 3 bits ( registrador destino ) = **011**
* 4 bits ( funct - variacoes das operacoes especificadas do opcode ) = **0001**

```

Ex. sub $s4, $s2, $s1;
        $s4 = 5 - 3 = 2
```

**and rs, rt, rd;**

* 3 bits ( opcode ) = **000**
* 3 bits ( registrador origem 1 ) = **100**
* 3 bits ( registrador origem 2 ) = **011**
* 3 bits ( registrador destino ) = **010**
* 4 bits ( funct - variacoes das operacoes especificadas do opcode ) = **0010**

**or rs, rt, rd;**

* 3 bits ( opcode ) = **000**
* 3 bits ( registrador origem 1 ) = **010**
* 3 bits ( registrador origem 2 ) = **100**
* 3 bits ( registrador destino ) = **001**
* 4 bits ( funct - variacoes das operacoes especificadas do opcode ) = **0011**

**xor rs, rt, rd;**

* 3 bits ( opcode ) = **000**
* 3 bits ( registrador origem 1 ) = **001**
* 3 bits ( registrador origem 2 ) = **010**
* 3 bits ( registrador destino ) = **101**
* 4 bits ( funct - variacoes das operacoes especificadas do opcode ) = **0100**

---
**sw rs, Offset(rt);**

* 3 bits ( opcode ) = **001**
* 3 bits ( registrador fonte ) = **000**
* 3 bits ( registrador destino ) = **0011**
* 7 bits ( imediato ) = **0000000**


```
Ex.: sw $s0, 3($s0);
         $s0 = ($s0) + 32'd3;
         $s0 = 8;
```
*/

# Commented out IPython magic to ensure Python compatibility.
# %%file instructions.txt
# 01100001
# 00001111
# 01100010
# 00000101
# 00001010
# 01010000
# 00001010
# 00110001
# 00010001
# 10100010
# 00001010
# 00010011
# 00000101
# 01010100
# 00100001
# 10000000

# Commented out IPython magic to ensure Python compatibility.
# %%file instructions_memory.sv
# `define NULL 0
# 
# // Memória de instrucoes
# module instructions_memory ( clk, pc, instruction );
#   // Declaracao de portas
#   input clk;
#   input [15:0] pc;
#   output [15:0] instruction;
# 
#   integer f, r; // arquivo
#   reg [7:0] data = 8'd0;
#   integer counterMemory = 16'd0;
# 
#   // Criando uma memoria de instrucoes com 100 enderecos de 8 bits
#   reg [7:0] memoriaInstrucoes [99:0];
# 
#   initial begin
#     // Abrindo arquivo
#     f = $fopen("/content/instructions.txt","r");
#     // Se arquivo nao contem nenhuma informacao
#     if ( f == `NULL ) begin
#       $display("Arquivo sem instrucoes");
#       $finish;
#     end
# 
#     while (! $feof( f )) begin
#       r = $fscanf( f,"%8b\n", data);
#       memoriaInstrucoes[counterMemory] = data;
#       counterMemory = counterMemory + 16'd1;
#     end
# 
#     // Fechando arquivo
#     $fclose( f );
#   end
# 
#   // Atribuindo o valor da instrucao
#   assign instruction = { memoriaInstrucoes[ pc + 16'd0 ],
#                          memoriaInstrucoes[ pc + 16'd1 ]};
# 
# endmodule

"""**Dados**: Cada linha do banco de registradores contém um dado.

```
  endereço do registrador
       | 3 bits  |
        --------------------------------------
dados  |    15    |    5    |  . . .  |        |  (16 bits)
        --------------------------------------
                     16 endereços
```
"""

# Commented out IPython magic to ensure Python compatibility.
# %%file register_bank.sv
# // Banco de registradores
# module register_bank ( clk, comandos, instruction, data_in, out1, out2, out3, memory );
#   // Declaracao de portas
#   input clk;
#   input [9:0] comandos;
#   input [15:0] instruction;
#   input [15:0] data_in;
#   output [15:0] out1, out2, out3;
#   // 5 enderecos do banco de registradores
#   output reg [63:0] memory;
# 
#   // Variaveis intermediarias
#   wire RegDst = comandos[9];
#   wire ALUscr = comandos[8];
#   wire RegWrite = comandos[6];
# 
#   wire [2:0] addr_regd, addr_reg1, addr_reg2;
#   assign addr_reg1 = instruction[12:10];
#   assign addr_reg2 = instruction[9:7];
#   assign addr_regd = ( RegDst == 1'b0 ) ? instruction[9:7] : instruction[6:4];
# 
#   wire [15:0] extensao = { 8'd0, instruction[7:0] };
# 
#   // Criando um banco de registradores com 16 enderecos de 16 bits
#   reg [15:0] registerBank [15:0];
# 
#   // Inicializando o banco de registradores com valores iniciais
#   integer i;
#   initial begin
#     for (i = 0; i < 16; i = i + 1) begin
#       registerBank[i] <= 16'd0;
#     end
#   end
# 
#   // Descrevendo o comportamento de escrita no banco de registradores
#   always @(posedge clk, data_in ) begin
#     if ( RegWrite == 1'b1 ) begin
#       registerBank[addr_regd] <= data_in;
#     end
#   end
# 
#   assign out1 = registerBank[addr_reg1];
#   assign out2 = (ALUscr == 1'b1) ? extensao : registerBank[addr_reg2];
#   assign out3 = registerBank[addr_reg2];
# 
#   always @( posedge clk, data_in ) begin
#     memory <= {registerBank[0], registerBank[1], registerBank[2], registerBank[3]};
#   end
# 
# endmodule

# Commented out IPython magic to ensure Python compatibility.
# %%file ula.sv
# // Unidade logica aritmetica (ULA)
# module ula ( control_ula, in1, in2, out, zero );
#   // Declaracao de portas
#   input [2:0] control_ula;
#   input [15:0] in1, in2;
#   output reg [15:0] out;
#   output reg zero;
# 
#   // Descrevendo o comportamento da ULA
#   always @( in1, in2, control_ula ) begin
#     case ({control_ula})
#       3'b000 : out = in1 + in2;
#       3'b001 : out = in1 - in2;
#       3'b010 : out = in1 & in2;
#       3'b011 : out = in1 | in2;
#       3'b100 : out = in1 ^ in2;
#       default : out = 16'd0;
#     endcase
#     if ( out == -16'd0 ) begin
#       zero = 1'b1;
#     end
#     else begin
#       zero = 1'b0;
#     end
#   end
# 
# endmodule

# Commented out IPython magic to ensure Python compatibility.
# %%file control.sv
# // Controle
# module control ( opcode, out );
#   input [2:0] opcode;
#   // RegDst, ALUscr, MemtoReg, RegWrite, MemRead, MemWrite, Branch, ALUOp, Jump
#   output reg [9:0] out;
# 
#   always @( opcode ) begin
#     casex ({opcode})
#       3'b000 : out = 10'b1001000000; // Tipo R
#       3'b011 : out = 10'b0111100110; // LW (Tipo I)
#       3'b001 : out = 10'b0100010110; // SW (Tipo I)
#       3'b010 : out = 10'b0000000001; // (Tipo J)
#       3'b100 : out = 10'bx0x0001010; // BEQ (Tipo I)
#       default   : out = 10'bxxxxxxxxxx;
#     endcase
#   end
# 
# endmodule

# Commented out IPython magic to ensure Python compatibility.
# %%file control_ULA.sv
# // Controle
# module control_ULA ( ULAOp, funct, out );
#   input [1:0] ULAOp;
#   input [3:0] funct;
#   output reg [2:0] out;
# 
#   always @( ULAOp, funct ) begin
#     casex ({ULAOp,funct})
#       6'b11xxxx : out = 3'b000; // LW, SW (Tipo I)
#       6'b000000 : out = 3'b000; // soma
#       6'b000001 : out = 3'b001; // subtracao
#       6'b000010 : out = 3'b010; // e
#       6'b000011 : out = 3'b011; // ou
#       6'b000100 : out = 3'b100; // xor
#       6'b01xxxx : out = 3'b110; // BEQ (Tipo I)
#     endcase
#   end
# endmodule

# Commented out IPython magic to ensure Python compatibility.
# %%file data_memory.sv
# // Memoria de dados
# module data_memory ( clk, addr, write_data, MemWrite, MemRead, MemtoReg, read_data, memory );
#   input clk;
#   input MemWrite, MemRead, MemtoReg;
#   input [15:0] addr; // endereco memoria
#   input [15:0] write_data; // dado escrito
#   output reg [15:0] read_data; // dado lido
#   output reg [63:0] memory;
# 
#   // Construindo memoria com 256 palavras de 32 bits
#   reg [15:0] ram [0:127];
# 
#   // Inicializando a memoria com valores iniciais
#   integer i;
#   initial begin
#     for (i = 0; i < 128; i = i + 1) begin
#       ram[i] = 2*i;
#     end
#   end
# 
#   always @( posedge clk, addr, MemWrite,MemRead,MemtoReg ) begin
#     casex ({MemWrite,MemRead,MemtoReg})
#       3'b000 : read_data <= addr;
#       3'b011 : read_data <= ram[ addr ];
#       3'b10x : ram[ addr ] <= write_data;
#     endcase
#   end
# 
#   always @( posedge clk, addr, MemWrite,MemRead,MemtoReg) begin
#     memory <= {ram[0], ram[1], ram[2], ram[3]};
#   end
# 
# endmodule

# Commented out IPython magic to ensure Python compatibility.
# %%file testbench.v
# 
# `include "pc.sv"
# `include "instructions_memory.sv"
# `include "control.sv"
# `include "control_ULA.sv"
# `include "register_bank.sv"
# `include "ula.sv"
# `include "data_memory.sv"
# 
# module testbench();
#   // Test period
#   parameter period = 2;
# 
#   reg clk;
#   wire [9:0] commands;
#   wire [15:0] instruction, address;
#   wire zero;
# 
#   // Program counter
#   pc pc(clk, commands, instruction, zero, address);
# 
#   // Instruction memory
#   instructions_memory instruction_memory( clk, address, instruction );
# 
#   wire [2:0] opcode;
#   assign opcode = instruction[15:13];
# 
#   // Control
#   control c( opcode, commands);
# 
#   wire [15:0] data_ula, out1, out2, out3, r_data;
#   wire [63:0] registradores; // 3 enderecos do banco de registradores
# 
#   // Register bank
#   register_bank register_bank( clk, commands, instruction, data_ula, out1, out2, out3, registradores );
# 
#   wire [2:0] ula_control;
# 
#   wire [1:0] ULAOp;
#   assign ULAOp = commands[2:1];
# 
#   wire [3:0] funct;
#   assign funct = instruction[3:0];
# 
#   // ULA control
#   control_ULA control_ULA( ULAOp, funct, ula_control );
# 
#   wire [15:0] result;
# 
#   // ULA
#   ula ula( ula_control, out1, out2, result, zero );
# 
#   wire MemWrite, MemRead, MemtoReg;
#   assign MemWrite = commands[4];
#   assign MemRead = commands[5];
#   assign MemtoReg = commands[7];
# 
#   wire [63:0] memoria;
# 
#   // Memory
#   data_memory data_memory( clk, result, out3, MemWrite, MemRead, MemtoReg, data_ula, memoria );
# 
#   initial begin
#     $dumpfile("cpu.vcd");
#     $dumpvars;
#     clk <= 0;
#     $display("Registrador     |   Memoria");
#     $display(" r0  r1  r2  r3 | m0 m1 m2 m3");
#     $display("-------------------------");
#     $monitor("  %1d   %1d   %1d   %1d | %1d  %1d  %1d  %1d", registradores[63:48], registradores[47:32], registradores[31:16], registradores[15:0], memoria[63:48], memoria[47:32], memoria[31:16], memoria[15:0]);
#     #period;
# 
#     #period;
# 
#     #period;
# 
#     #period;
# 
#     #period;
# 
#     #period;
# 
#     #period;
# 
#     #period;
# 
#     #period;
# 
#     #period;
# 
#     #period;
# 
#     $finish;
#   end
# 
#   always begin
#     clk = ~clk;
#     #period;
#   end
# endmodule

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# iverilog testbench.v -o cpu
# vvp cpu

# Commented out IPython magic to ensure Python compatibility.
# %%waveform cpu.vcd
# 
# sign_list = ['testbench.clk', 'testbench.instruction', 'testbench.out1', 'testbench.out2', 'testbench.out3', 'testbench.result', 'testbench.data_ula']
# time_begin = 0
# time_end = 25
# base = 'dec' # bin, dec, dec2, hex, octal